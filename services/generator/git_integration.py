"""
Git integration module for pushing generated Playwright tests to repositories.
Coordinates between generator, git service, and automations service.
"""
import os
import httpx
from datetime import datetime, timezone
from pathlib import Path
from typing import Literal

GIT_SERVICE_URL = os.getenv("GIT_SERVICE_URL", "http://git:8000")
TESTS_REPO_URL = os.getenv("TESTS_REPO_URL", "")  # Git repo URL for tests
TESTS_REPO_BRANCH = os.getenv("TESTS_REPO_BRANCH", "main")  # Base branch
TEST_FILES_PATH = os.getenv("TEST_FILES_PATH", "tests/generated")  # Path within repo


async def push_test_to_git(
    test_case_id: str,
    test_title: str,
    script_content: str,
    provider: Literal["github", "gitlab", "azure"],
    repo_url: str | None = None,
    base_branch: str | None = None,
    ssh_key_name: str | None = None
) -> dict:
    """
    Push a generated Playwright test to a Git repository and create a PR/MR.
    
    Args:
        test_case_id: ID of the test case
        test_title: Human-readable test title
        script_content: Generated Playwright JavaScript code
        provider: Git provider (github, gitlab, azure)
        repo_url: Repository URL (uses env var if None)
        base_branch: Base branch to create PR from (uses env var if None)
        ssh_key_name: SSH key name for authentication (optional)
    
    Returns:
        dict with keys: success, pr_url, branch_name, file_path
    """
    repo_url = repo_url or TESTS_REPO_URL
    base_branch = base_branch or TESTS_REPO_BRANCH
    
    if not repo_url:
        raise ValueError("TESTS_REPO_URL environment variable not set and no repo_url provided")
    
    async with httpx.AsyncClient(timeout=120) as client:
        # 1. Clone repository (or pull if exists)
        repo_name = Path(repo_url).stem.replace('.git', '')
        
        try:
            # Try to pull latest changes if repo exists
            pull_resp = await client.post(
                f"{GIT_SERVICE_URL}/pull",
                json={
                    "repo_path": repo_name,
                    "branch": base_branch,
                    "ssh_key_name": ssh_key_name
                }
            )
            pull_resp.raise_for_status()
            cloned = False
        except:
            # Clone if doesn't exist
            clone_resp = await client.post(
                f"{GIT_SERVICE_URL}/clone",
                json={
                    "repo_url": repo_url,
                    "branch": base_branch,
                    "target_dir": repo_name,
                    "ssh_key_name": ssh_key_name
                }
            )
            clone_resp.raise_for_status()
            cloned = True
        
        # 2. Create feature branch
        timestamp = int(datetime.now(timezone.utc).timestamp())
        branch_name = f"feat/test-{test_case_id}-{timestamp}"
        
        branch_resp = await client.post(
            f"{GIT_SERVICE_URL}/branch/create",
            json={
                "repo_path": repo_name,
                "branch_name": branch_name
            }
        )
        branch_resp.raise_for_status()
        
        # 3. Write test file using git service write-file endpoint
        # Sanitize test title for filename
        safe_title = "".join(c if c.isalnum() or c in (' ', '-', '_') else '_' for c in test_title)
        safe_title = safe_title.replace(' ', '-').lower()[:50]
        
        file_path = f"{TEST_FILES_PATH}/{safe_title}-{test_case_id}.spec.js"
        
        # Generate complete Playwright test file
        full_test_content = generate_playwright_test_file(test_title, script_content, test_case_id)
        
        write_resp = await client.post(
            f"{GIT_SERVICE_URL}/file/write",
            json={
                "repo_path": repo_name,
                "file_path": file_path,
                "content": full_test_content,
                "branch": branch_name
            }
        )
        write_resp.raise_for_status()
        
        # 4. Commit changes
        commit_message = f"feat: Add automated test for {test_title}\n\nTest ID: {test_case_id}\nGenerated by AI Test Platform"
        
        commit_resp = await client.post(
            f"{GIT_SERVICE_URL}/commit",
            json={
                "repo_path": repo_name,
                "message": commit_message,
                "files": [file_path]
            }
        )
        commit_resp.raise_for_status()
        
        # 5. Push branch
        push_resp = await client.post(
            f"{GIT_SERVICE_URL}/push",
            json={
                "repo_path": repo_name,
                "branch": branch_name,
                "ssh_key_name": ssh_key_name
            }
        )
        push_resp.raise_for_status()
        
        # 6. Create Pull/Merge Request
        pr_title = f"[Auto-Generated] Test: {test_title}"
        pr_description = f"""## Auto-Generated Test Case

**Test ID:** `{test_case_id}`
**Test Title:** {test_title}
**Generated:** {datetime.now(timezone.utc).isoformat()}

This test was automatically generated by the AI Test Platform.

### Files Changed:
- `{file_path}`

### How to Run:
```bash
npx playwright test {file_path}
```

### Next Steps:
1. Review the generated test code
2. Update selectors if needed
3. Add test data/fixtures as required
4. Approve and merge when ready
"""
        
        mr_resp = await client.post(
            f"{GIT_SERVICE_URL}/merge-request/create",
            json={
                "repo_path": repo_name,
                "source_branch": branch_name,
                "target_branch": base_branch,
                "title": pr_title,
                "description": pr_description,
                "provider": provider
            }
        )
        mr_resp.raise_for_status()
        mr_data = mr_resp.json()
        
        return {
            "success": True,
            "pr_url": mr_data.get("url"),
            "pr_number": mr_data.get("number"),
            "branch_name": branch_name,
            "file_path": file_path,
            "repo_name": repo_name,
            "cloned": cloned
        }


def generate_playwright_test_file(title: str, script_content: str, test_case_id: str) -> str:
    """
    Generate a complete Playwright test file with proper structure.
    
    Args:
        title: Test title
        script_content: Generated test script
        test_case_id: Test case ID for traceability
    
    Returns:
        Complete Playwright test file content
    """
    # Ensure script_content is indented properly
    indented_script = "\n".join(f"  {line}" if line.strip() else "" for line in script_content.split("\n"))
    
    test_file = f"""// Auto-generated test by AI Test Platform
// Test ID: {test_case_id}
// Generated: {datetime.now(timezone.utc).isoformat()}

import {{ test, expect }} from '@playwright/test';

test.describe('{title}', () => {{
  test('should execute {title}', async ({{ page }}) => {{
{indented_script}
  }});
}});
"""
    return test_file


async def trigger_test_execution(
    branch_name: str,
    file_path: str,
    repo_name: str
) -> dict:
    """
    Simulate a pipeline trigger for test execution.
    In a real pipeline, this would be handled by CI/CD webhooks.
    For now, we can at least return instructions for manual execution.
    
    Args:
        branch_name: Git branch name
        file_path: Path to test file
        repo_name: Repository name
    
    Returns:
        dict with execution instructions
    """
    return {
        "execution_type": "manual",
        "instructions": {
            "description": "To run this test, execute the following commands:",
            "commands": [
                f"git clone <repo-url> {repo_name}",
                f"cd {repo_name}",
                f"git checkout {branch_name}",
                "npm install",
                f"npx playwright test {file_path}",
                "# Or run all tests:",
                "npx playwright test"
            ]
        },
        "webhook_suggestion": {
            "description": "To automate test execution, configure a webhook in your Git provider:",
            "github": "Settings → Webhooks → Add webhook → Set URL to your CI/CD endpoint",
            "gitlab": "Settings → Webhooks → Add webhook → Trigger on 'Merge Request events'",
            "azure": "Project Settings → Service hooks → Web Hooks → Subscribe to 'Pull request created'"
        },
        "ci_config_examples": {
            "github_actions": ".github/workflows/playwright.yml",
            "gitlab_ci": ".gitlab-ci.yml",
            "azure_pipelines": "azure-pipelines.yml"
        }
    }
